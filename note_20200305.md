协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。例如，为了支持迭代，只需实现\_\_getitem\_\_方法，没必要提供\_\_len\_\_方法。

大量使用isinstance可能表明面向对象设计得不好，不过在\_\_getitem\_\_方法中使用它处理切片是合理的。

属性查找失败后，解释器会调用\_\_getattr\_\_方法。简单来说，对my_obj.x表达式，Python会检查my_obj实例有没有名为x的属性；如果没有，到类（my_obj.\_\_class\_\_）中查找；如果还没有，顺着继承树继续查找。如果依旧找不到，调用my_obj所属类中定义的\_\_getattr\_\_方法，传入self和属性名称的字符串形式（如'x'）。

super（　）函数用于动态访问超类的方法，对Python这样支持多重继承的动态语言来说，必须能这么做。程序员经常使用这个函数把子类方法的某些任务委托给超类中适当的方法.

使用reduce函数时最好提供第三个参数，reduce(function, iterable, initializer)，这样能避免这个异常：TypeError: reduce（　） of empty sequence with no initial value（这个错误消息很棒，说明了问题，还提供了解决方法）。如果序列为空，initializer是返回的结果；否则，在归约中使用它作为第一个参数，因此应该使用恒等值。比如，对+、|和^来说， initializer应该是0；而对*和&来说，应该是1。

在Python 2中使用map函数效率低些，因为map函数要使用结果构建一个列表。但是在Python 3中，map函数是惰性的，它会创建一个生成器，按需产出结果，因此能节省内存.

使用for循环迭代元素不用处理索引变量，还能避免很多缺陷，但是需要一些特殊的实用函数协助。其中一个是内置的zip函数。使用zip函数能轻松地并行迭代两个或更多可迭代对象，它返回的元组可以拆包成变量，分别对应各个并行输入中的一个元素。